-- full graph
TP(Sym(2),OrderingGT(Sym(1),Const(10)))
TP(Sym(3),IntPlus(Sym(1),Const(1)))
TP(Sym(4),SimpleLoop(Const(100),Sym(1),ArrayIfElem(Sym(2),Block(Sym(3)))))
TP(Sym(5),ArrayLength(Sym(4)))
TP(Sym(7),ArrayIndex(Sym(4),Sym(6)))
TP(Sym(8),IntPlus(Sym(7),Const(2)))
TP(Sym(9),SimpleLoop(Sym(5),Sym(6),ArrayElem(Block(Sym(8)))))
TP(Sym(11),ArrayIndex(Sym(4),Sym(10)))
TP(Sym(12),OrderingGT(Sym(11),Const(20)))
TP(Sym(13),IntPlus(Sym(11),Const(3)))
TP(Sym(14),SimpleLoop(Sym(5),Sym(10),ArrayIfElem(Sym(12),Block(Sym(13)))))
TP(Sym(16),ArrayIndex(Sym(4),Sym(15)))
TP(Sym(18),IntPlus(Sym(17),Sym(16)))
TP(Sym(19),SimpleLoop(Sym(16),Sym(17),ArrayElem(Block(Sym(18)))))
TP(Sym(20),SimpleLoop(Sym(5),Sym(15),FlattenElem(Block(Sym(19)))))
TP(Sym(22),ArrayIndex(Sym(4),Sym(21)))
TP(Sym(23),IntDoubleValue(Sym(22)))
TP(Sym(24),DoublePlus(Const(2.0),Sym(23)))
TP(Sym(25),SimpleLoop(Sym(5),Sym(21),ReduceElem(Block(Sym(24)))))
TP(Sym(26),ArrayIndex(Sym(9),Const(0)))
TP(Sym(27),Reflect(Print(Sym(26)),Summary(true,true,false,false,false,false,List(),List(),List(),List()),List()))
TP(Sym(28),ArrayIndex(Sym(14),Const(0)))
TP(Sym(29),Reflect(Print(Sym(28)),Summary(true,true,false,false,false,false,List(),List(),List(),List()),List(Sym(27))))
TP(Sym(30),ArrayIndex(Sym(20),Const(0)))
TP(Sym(31),Reflect(Print(Sym(30)),Summary(true,true,false,false,false,false,List(),List(),List(),List()),List(Sym(29))))
TP(Sym(32),Reflect(Print(Sym(25)),Summary(true,true,false,false,false,false,List(),List(),List(),List()),List(Sym(31))))
TP(Sym(33),Reify(Sym(32),Summary(true,true,false,false,false,false,List(),List(),List(),List()),List(Sym(27), Sym(29), Sym(31), Sym(32))))

-- before transformation
var x4 = new ArrayBuilder[Int]
for (x1 <- 0 until 100) {
val x2 = x1 > 10
val x3 = x1 + 1
if (x2) x4 += x3
}
val x5 = x4.length
var x9 = new Array[Int](x5)
for (x6 <- 0 until x5) {
val x7 = x4.apply(x6)
val x8 = x7 + 2
x9(x6) = x8
}
val x26 = x9.apply(0)
val x27 = println(x26)
var x14 = new ArrayBuilder[Int]
for (x10 <- 0 until x5) {
val x11 = x4.apply(x10)
val x12 = x11 > 20
val x13 = x11 + 3
if (x12) x14 += x13
}
val x28 = x14.apply(0)
val x29 = println(x28)
var x20 = new ArrayBuilder[Int]
for (x15 <- 0 until x5) {
val x16 = x4.apply(x15)
var x19 = new Array[Int](x16)
for (x17 <- 0 until x16) {
val x18 = x17 + x16
x19(x17) = x18
}
x20 ++= x19
}
val x30 = x20.apply(0)
val x31 = println(x30)
var x25 = 0
for (x21 <- 0 until x5) {
val x22 = x4.apply(x21)
val x23 = x22.doubleValue()
val x24 = 2.0 + x23
x25 += x24
}
val x32 = println(x25)

-- vertical transformation

(VFT) No producers found for TP(Sym(4),SimpleLoop(Const(100),Sym(1),ArrayIfElem(Sym(2),Block(Sym(3)))))

(VFT) Fusing consumer TP(Sym(9),SimpleLoop(Sym(5),Sym(6),ArrayElem(Block(Sym(8))))) with real producer: Sym(4)
(VFT) General fusion: remap index to Sym(1), SimpleIndex to Sym(3).
(VFT) SimpleCollectIf+SimpleCollect fusion: use producer loop with consumer body.
(VFT) Finished fusion of prod: Sym(4) and cons: Sym(9), the resulting fused loop is Sym(35)

(VFT) Fusing consumer TP(Sym(14),SimpleLoop(Sym(5),Sym(10),ArrayIfElem(Sym(12),Block(Sym(13))))) with real producer: Sym(4)
(VFT) General fusion: remap index to Sym(1), SimpleIndex to Sym(3).
(VFT) SimpleCollectIf+SimpleCollectIf fusion: add producer conditions to consumer loop.
(VFT) Finished fusion of prod: Sym(4) and cons: Sym(14), the resulting fused loop is Sym(41)

(VFT) Fusing consumer TP(Sym(20),SimpleLoop(Sym(5),Sym(15),FlattenElem(Block(Sym(19))))) with real producer: Sym(4)
(VFT) General fusion: remap index to Sym(1), SimpleIndex to Sym(3).
(VFT) SimpleCollectIf+MultiCollect fusion: add if-then-else with empty array to consumer.

(VFT) No producers found for TP(Sym(19),SimpleLoop(Sym(16),Sym(17),ArrayElem(Block(Sym(18)))))
(VFT) Finished fusion of prod: Sym(4) and cons: Sym(20), the resulting fused loop is Sym(48)

(VFT) Fusing consumer TP(Sym(25),SimpleLoop(Sym(5),Sym(21),ReduceElem(Block(Sym(24))))) with real producer: Sym(4)
(VFT) General fusion: remap index to Sym(1), SimpleIndex to Sym(3).
(VFT) SimpleCollectIf+Reduce fusion: add if-then-else with neutral element to consumer.
(VFT) Finished fusion of prod: Sym(4) and cons: Sym(25), the resulting fused loop is Sym(54)

(VFT) all vertically fused: List(Sym(35), Sym(4), Sym(48), Sym(54), Sym(41))

-- after vertical transformation
var x35 = new ArrayBuilder[Int]
for (x1 <- 0 until 100) {
val x2 = x1 > 10
val x3 = x1 + 1
val x34 = x3 + 2
if (x2) x35 += x34
}
val x36 = x35.apply(0)
val x37 = println(x36)
var x41 = new ArrayBuilder[Int]
for (x1 <- 0 until 100) {
val x2 = x1 > 10
val x3 = x1 + 1
val x38 = x3 > 20
val x39 = x38 && x2
val x40 = x3 + 3
if (x39) x41 += x40
}
val x42 = x41.apply(0)
val x43 = println(x42)
var x44 = new Array[Int](0)
var x48 = new ArrayBuilder[Int]
for (x1 <- 0 until 100) {
val x2 = x1 > 10
val x47 = if (x2) {
val x3 = x1 + 1
var x46 = new Array[Int](x3)
for (x17 <- 0 until x3) {
val x45 = x17 + x3
x46(x17) = x45
}
x46
} else {
x44
}
x48 ++= x47
}
val x49 = x48.apply(0)
val x50 = println(x49)
var x54 = 0
for (x1 <- 0 until 100) {
val x2 = x1 > 10
val x53 = if (x2) {
val x3 = x1 + 1
val x51 = x3.doubleValue()
val x52 = 2.0 + x51
x52
} else {
0.0
}
x54 += x53
}
val x55 = println(x54)

-- horizontal transformation
(HFT) Recording Sym(35), no fusion
(HFT) Fusing Sym(41) with containing fusion set FusedSet(shape = Const(100), indexSym = Sym(1), loopSyms = List(Sym(35), Sym(4), Sym(48), Sym(54), Sym(41)))
(HFT) - already using same index Sym(1)
(HFT) Fusing Sym(48) with containing fusion set FusedSet(shape = Const(100), indexSym = Sym(1), loopSyms = List(Sym(35), Sym(4), Sym(48), Sym(54), Sym(41)))
(HFT) - already using same index Sym(1)
(HFT) Recording Sym(46), no fusion
(HFT) Fusing Sym(54) with containing fusion set FusedSet(shape = Const(100), indexSym = Sym(1), loopSyms = List(Sym(35), Sym(4), Sym(48), Sym(54), Sym(41)))
(HFT) - already using same index Sym(1)

(HFT) all horizontally fused: List(Sym(35), Sym(41), Sym(48), Sym(54))

-- after horizontal transformation
var x35 = new ArrayBuilder[Int]
for (x1 <- 0 until 100) {
val x2 = x1 > 10
val x3 = x1 + 1
val x34 = x3 + 2
if (x2) x35 += x34
}
val x36 = x35.apply(0)
val x37 = println(x36)
var x41 = new ArrayBuilder[Int]
for (x1 <- 0 until 100) {
val x2 = x1 > 10
val x3 = x1 + 1
val x38 = x3 > 20
val x39 = x38 && x2
val x40 = x3 + 3
if (x39) x41 += x40
}
val x42 = x41.apply(0)
val x43 = println(x42)
var x44 = new Array[Int](0)
var x48 = new ArrayBuilder[Int]
for (x1 <- 0 until 100) {
val x2 = x1 > 10
val x47 = if (x2) {
val x3 = x1 + 1
var x46 = new Array[Int](x3)
for (x17 <- 0 until x3) {
val x45 = x17 + x3
x46(x17) = x45
}
x46
} else {
x44
}
x48 ++= x47
}
val x49 = x48.apply(0)
val x50 = println(x49)
var x54 = 0
for (x1 <- 0 until 100) {
val x2 = x1 > 10
val x53 = if (x2) {
val x3 = x1 + 1
val x51 = x3.doubleValue()
val x52 = 2.0 + x51
x52
} else {
0.0
}
x54 += x53
}
val x55 = println(x54)

-- fusion
(FTO) Fusing these loops into one fat TTP: 
TTP(List(Sym(35)),List(SimpleLoop(Const(100),Sym(1),ArrayIfElem(Sym(2),Block(Sym(34))))),SimpleFatLoop(Const(100),Sym(1),List(ArrayIfElem(Sym(2),Block(Sym(34))))))
TTP(List(Sym(41)),List(SimpleLoop(Const(100),Sym(1),ArrayIfElem(Sym(39),Block(Sym(40))))),SimpleFatLoop(Const(100),Sym(1),List(ArrayIfElem(Sym(39),Block(Sym(40))))))
TTP(List(Sym(48)),List(SimpleLoop(Const(100),Sym(1),FlattenElem(Block(Sym(47))))),SimpleFatLoop(Const(100),Sym(1),List(FlattenElem(Block(Sym(47))))))
TTP(List(Sym(54)),List(SimpleLoop(Const(100),Sym(1),ReduceElem(Block(Sym(53))))),SimpleFatLoop(Const(100),Sym(1),List(ReduceElem(Block(Sym(53))))))

var x44 = new Array[Int](0)
var x35 = new ArrayBuilder[Int]
var x41 = new ArrayBuilder[Int]
var x48 = new ArrayBuilder[Int]
var x54 = 0
for (x1 <- 0 until 100) {
val x2 = x1 > 10
val x3 = x1 + 1
val x34 = x3 + 2
val x38 = x3 > 20
val x39 = x38 && x2
val x40 = x3 + 3
val x47 = if (x2) {
var x46 = new Array[Int](x3)
for (x17 <- 0 until x3) {
val x45 = x17 + x3
x46(x17) = x45
}
x46
} else {
x44
}
val x53 = if (x2) {
val x51 = x3.doubleValue()
val x52 = 2.0 + x51
x52
} else {
0.0
}
if (x2) x35 += x34
if (x39) x41 += x40
x48 ++= x47
x54 += x53
}
val x36 = x35.apply(0)
val x37 = println(x36)
val x42 = x41.apply(0)
val x43 = println(x42)
val x49 = x48.apply(0)
val x50 = println(x49)
val x55 = println(x54)
-- done
