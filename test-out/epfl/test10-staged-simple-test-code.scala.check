package scala.virtualization.lms
package epfl
package test10
package original

import test10.original.Conversions._
import test10.original.Operations._
import test10.original.SpecificOperations._

/*****************************************
  Emitting Generated Code                  
*******************************************/
class Experiment extends ((scala.Tuple2[scala.virtualization.lms.epfl.test10.original.MDArray[Int], scala.virtualization.lms.epfl.test10.original.MDArray[Int]])=>(scala.virtualization.lms.epfl.test10.original.MDArray[Int])) {
  def apply(x6:scala.Tuple2[scala.virtualization.lms.epfl.test10.original.MDArray[Int], scala.virtualization.lms.epfl.test10.original.MDArray[Int]]): scala.virtualization.lms.epfl.test10.original.MDArray[Int] = {
    val x7 = x6._1
    val x8 = x6._2
    // RuntimeCheck : POST:   V7 = [u14  u13  u12]                                   from Bubble up value for Sym(7) <- InfixOp(+: Sym(7) and Sym(8))
    // RuntimeCheck : POST:   S7 = [3]                                               from Bubble up shape for Sym(7) <- InfixOp(+: Sym(7) and Sym(8))
    // RuntimeCheck : PRE:    S7 = S8 OR S8 = []                                     from InfixOp(+: Sym(7) and Sym(8))
    // Shape: V9=[u11  u10  u9] and S9=[3]
    val x9: MDArray[Int] = {
      // WARNING: Operation not specialized on {arrays|scalars}!
      if (shape(shape(x8)).content()(0) == 0) {
        val result = new Array[Int](shape(x7).content().foldLeft(1)((a,b) => a*b))
        for(i <- List.range(0, result.length))
        result(i) = x7.content()(i) +  x8
        internalReshape(shape(x7), result, "infixOpAA")
      } else {
        val result = new Array[Int](shape(x7).content().foldLeft(1)((a,b) => a*b))
        for(i <- List.range(0, result.length))
        result(i) = x7.content()(i) +  x8.content()(i)
        internalReshape(shape(x7), result, "infixOpAA")
      }
    }
    // Shape: V10=[10  10  10] and S10=[3]
    val x10: MDArray[Int] = internalReshape(3::Nil, Array(10, 10, 10), "knownAtCompileTime")
    // RuntimeCheck : POST:   V10 = [10  10  10]                                     from Bubble up value for Sym(10) <- InfixOp(+: Sym(9) and Sym(10))
    // RuntimeCheck : POST:   S10 = [3]                                              from Bubble up shape for Sym(10) <- InfixOp(+: Sym(9) and Sym(10))
    // RuntimeCheck : POST:   V9 = [u11  u10  u9]                                    from Bubble up value for Sym(9) <- InfixOp(+: Sym(9) and Sym(10))
    // RuntimeCheck : POST:   S9 = [3]                                               from Bubble up shape for Sym(9) <- InfixOp(+: Sym(9) and Sym(10))
    // RuntimeCheck : PRE:    S9 = S10 OR S10 = []                                   from InfixOp(+: Sym(9) and Sym(10))
    // Shape: V11=[u8  u7  u6] and S11=[3]
    val x11: MDArray[Int] = {
      val result = new Array[Int](shape(x9).content().foldLeft(1)((a,b) => a*b))
      for(i <- List.range(0, result.length))
      result(i) = x9.content()(i) +  x10.content()(i)
      internalReshape(shape(x9), result, "infixOpAA")
    }
    x11
  }
}
/*****************************************
  End of Generated Code                  
*******************************************/
